import { spawn, ChildProcess } from 'child_process';
import { config } from 'dotenv';
import { AIService, CleanedParameters } from './ai/ai-service';
import { McpToolCall, McpResponse, PodDisplayData, ParsedMcpResponse } from './types';

// Load environment variables
config();

/**
 * Parse MCP protocol response to extract nested data
 */
function parseMcpResponse(parsed: any): ParsedMcpResponse | null {
  try {
    // Extract text content from MCP response
    const contentText = parsed.result?.content?.[0]?.text;
    if (!contentText) {
      return null;
    }

    // Parse nested JSON string
    const resultData = JSON.parse(contentText);
    return resultData;
  } catch (error) {
    return null;
  }
}

/**
 * Display pods as a formatted table
 */
function displayPodsAsTable(pods: PodDisplayData[], namespace: string, total: number): void {
  console.log(`\nğŸš€ Found ${total} pods in namespace: ${namespace}`);
  console.log('='.repeat(50));

  // Format table data
  const tableData = pods.map((pod) => ({
    Name: pod.name,
    Status: pod.status,
    IP: pod.ip || 'Pending',
    Node: pod.node || 'Pending'
  }));

  console.table(tableData);
}

/**
 * Display error information
 */
function displayError(error: any): void {
  console.log('\nâŒ Operation failed:');
  if (typeof error === 'string') {
    console.error(error);
  } else if (error?.message) {
    console.error(error.message);
  } else {
    console.error('Unknown error occurred');
  }
}

async function main() {
  let serverProcess: ChildProcess | null = null;
  const aiService = new AIService();

  try {
    // 1. æ¥æ”¶å‘½ä»¤è¡Œå‚æ•°
    const rawArgs = process.argv.slice(2);
    console.log('[Client] Raw input parameters:', rawArgs);

    // 2. AI ä¸‰å‚æ•°æ¸…æ´—
    console.log('[AI] Cleaning parameters...');
    const cleanedParams = await aiService.parseRawInput(rawArgs);

    if (!cleanedParams) {
      console.error('[AI] Failed to clean parameters or missing required parameters');
      console.error('[AI] Required: 3 parameters [identifier, resource, namespace]');
      console.error('[AI] Example: node dist/client/index.js hzh pods ns-mh69tey1');
      process.exit(1);
    }

    console.log('[AI] Cleaned parameters:', JSON.stringify(cleanedParams, null, 2));

    // 3. å¯åŠ¨ Server è¿›ç¨‹
    console.log('[Client] Starting MCP Server...');
    serverProcess = spawn('npm', ['run', 'start:server'], {
      stdio: ['pipe', 'pipe', 'inherit'],
    });

    let responseReceived = false;
    let fullResponse = '';

    // 4. å¤„ç† Server è¾“å‡º
    serverProcess.stdout?.on('data', (data: Buffer) => {
      const chunk = data.toString();
      fullResponse += chunk;

      // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°å®Œæ•´çš„ JSON-RPC å“åº”
      try {
        const lines = fullResponse.split('\n').filter(line => line.trim());
        for (const line of lines) {
          if (line.includes('"result"') || line.includes('"error"')) {
            const parsed = JSON.parse(line);
            if (parsed.id === 1) { // åŒ¹é…æˆ‘ä»¬çš„è¯·æ±‚ID
              responseReceived = true;
              console.log('\n[Client] ===== FINAL RESULT =====');

              try {
                // æå– MCP åè®®åŒ…è£¹çš„æ–‡æœ¬å†…å®¹
                const resultData = parseMcpResponse(parsed);

                if (resultData && resultData.success && resultData.pods) {
                  displayPodsAsTable(resultData.pods, resultData.namespace!, resultData.total!);
                } else {
                  displayError(resultData?.error || 'Operation failed');
                }
              } catch (e) {
                console.log('âš ï¸  Failed to parse response, showing raw data:');
                console.log('Raw Args:', rawArgs);
                console.log('Cleaned Parameters:', JSON.stringify(cleanedParams, null, 2));
                console.log('Server Response:', JSON.stringify(parsed, null, 2));
              }
              break;
            }
          }
        }
      } catch (e) {
        // JSON è§£æå¤±è´¥ï¼Œç»§ç»­ç´¯ç§¯
      }
    });

    // 5. å¤„ç†è¿›ç¨‹é”™è¯¯
    serverProcess.on('error', (error: Error) => {
      console.error('[Client] Server process error:', error);
    });

    serverProcess.on('exit', (code: number | null, signal: string | null) => {
      console.log(`[Client] Server process exited with code ${code}${signal ? ` (signal: ${signal})` : ''}`);
    });

    // 6. ç­‰å¾… Server å°±ç»ªå¹¶å‘é€è¯·æ±‚
    await new Promise(resolve => setTimeout(resolve, 2000));

    console.log('[Client] Sending request to server...');
    const jsonRpcRequest = {
      jsonrpc: '2.0',
      id: 1,
      method: 'tools/call',
      params: {
        name: 'list_pods_by_ns',
        arguments: { namespace: cleanedParams.namespace }
      },
    };

    serverProcess.stdin?.write(JSON.stringify(jsonRpcRequest) + '\n');

    // 7. ç­‰å¾…å“åº” (ä¿æŒç°æœ‰é€»è¾‘)
    const maxWaitTime = 15000; // 15ç§’æœ€å¤§ç­‰å¾…æ—¶é—´
    const startTime = Date.now();

    while (!responseReceived && (Date.now() - startTime) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    if (!responseReceived) {
      console.log('\n[Client] ===== TIMEOUT =====');
      console.log('No response received within timeout period');
      console.log('Raw server output:', fullResponse);
    }

  } catch (error) {
    console.error('[Client] Error occurred:', error);
  } finally {
    // 8. ä¼˜é›…å…³é—­ (ä¿æŒç°æœ‰é€»è¾‘)
    console.log('[Client] Shutting down gracefully...');

    if (serverProcess) {
      // ç»™ Server æ—¶é—´å®Œæˆè¾“å‡º
      await new Promise(resolve => setTimeout(resolve, 1000));

      // ä¼˜é›…å…³é—­
      serverProcess.kill('SIGTERM');

      // ç­‰å¾…è¿›ç¨‹çœŸæ­£é€€å‡º
      await new Promise<void>(resolve => {
        if (serverProcess) {
          serverProcess.on('exit', resolve);
        } else {
          resolve();
        }
      });
    }

    console.log('[Client] Shutdown complete');
    process.exit(0);
  }
}

// Handle process termination
process.on('SIGINT', () => {
  console.log('\n[Client] Shutting down...');
  process.exit(0);
});

main().catch((error) => {
  console.error('[Client] Fatal error:', error);
  process.exit(1);
});